## 工作流程：

1. 挂载文件系统后，文件系统驱动程序向用户空间发送请求，用户空间查找对应标志检查是否支持该框架，如果支持则将eBPF程序加载到内核中（通过bpf_load_prog系统调用实现）。如果eBPF验证器检查扩展完整性失败，则使用普通的文件系统的功能，成功则启动JIT编译器处理扩展生成字节码。这里驱动程序本身不执行任何IO操作，也不自己处理请求。
2. 扩展安装在bpf_prog_type映射中，调用跳转需要文件系统驱动程序执行bpf_tail_call，同时一旦eBPF程序加载完毕，进程需要通知驱动程序内核扩展的信息
3. 文件系统接到eBPF加载完毕的通知，就可以开始执行在eBPF虚拟机环境下运行的扩展，文件IO可通过优化过的快速路径进行。

## 实现细节：

为文件系统提供eBPF支持，具体来说即借助eBPF添加额外的内核辅助函数，设计新的映射类型，以支持用户空间和内核的通信和高效IO。而这里同时也要修改文件系统驱动程序，使其首先调用eBPF扩展，在加载eBPF程序后，我们可以绕过用户空间守护程序，直接向下层文件系统传递IO请求。

下面是一些具体方式

1. #### 内核原数据缓存

​	lookup、getattr等元数据操作频繁的IO操作导致高延迟，借助eBPF在内核缓存元数据可以减少用户态与内核态切换。以lookup操作为例，利用eBPF可以定义一个SHashMap，由父节点标识符和下一个路径组件字符串参数生成复合键用于映射索引，对操作进行响应。对于用户空间守护进程对其他元数据操作（如getattr、getxattr、readlink）的回复可以使用映射进行缓存，并通过各自的扩展在内核中提供服务。这里还要注意，当文件或目录重命名时，要将相应的缓存查找回复作废。

与普通VFS缓存相比的优点：

VFS缓存是响应式的，eBPF可以主动缓存，内核在服务opendir请求时将它们插入BPF映射以减少到用户空间的转换，被缓存占用的空间也可以由用户空间从映射中删除。

2. #### IO快速路径

在IO过程中，一些简单的IO造成的不必要的上下文切换带来了很大开销。使用eBPF，如果不需要复杂的处理逻辑的IO可以直接采取快速路径，直接转发到主机文件系统而不引起上下文切换。eBPF读写内核扩展可以检查InodeMap，以检测目标文件是否可以直通访问，如果可以，则直接用一个特殊的返回值指示驱动程序将IO请求以相应下层inode对象作为参数传到下层文件系统



